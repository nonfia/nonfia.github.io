[{"content":"Java 插件化注解处理介绍 Java 插件化注解处理是 JDK 1.6 实现 JSR-269 规范 Pluggable Annotations Processing API（插入式注解处理API）后提供给开发者的一系列 API\nPluggable Annotation Processing API 的核心是 Annotation Processor（注解处理器），JSR 269 定义了一种服务提供者接口（SPI），允许开发者创建自己的注解处理器\n这些处理器可以在编译时被调用，以便检查、处理注解，并根据这些注解生成额外的源代码或其他文件。这种机制允许开发者在不改变原有代码逻辑的情况下，通过注解来引入新的行为或数据\n注解处理器 注解编译期处理流程最关键的一个类就是 Processor，它是注解处理器的接口类，我们所有需要对编译期处理注解的逻辑都需要实现 Processor 接口。当然，AbstractProcessor 抽象类帮我们写好了大部分都流程，所以我们只需要实现这个抽象类就可以很方便的定义一个注解处理器\n注解处理流程由多轮完成，每执行一次 process() 方法被称为一轮。每一轮都从编译器在源文件中搜索 注解 并选择适合这些注解的 注解处理器 开始，每个注解处理器依次在相应的源上被调用。 如果在执行此过程中产生了新代码，则将以生成的文件作为输入开始新一轮。这个过程一直持续到处理阶段没有新代码产生为止\nAbstractProcessor 是注解处理器的核心抽象类\n核心方法介绍 init 可以让我们在处理器的初始化阶段，通过 ProcessingEnvironment 来获取一些操作语法树需要的对象\npublic synchronized void init(ProcessingEnvironment processingEnv) getSupportedAnnotationTypes 指定需要处理的注解集合，默认从 @SupportedAnnotationTypes 中读取\npublic Set\u0026lt;String\u0026gt; getSupportedAnnotationTypes() @SupportedAnnotationTypes 使用，指定注解 com.brainy.nonfia.apt.annotation.Log\n@SupportedAnnotationTypes(\u0026#34;com.brainy.nonfia.apt.annotation.Log\u0026#34;) public class LogProcessor extends AbstractProcessor { } getSupportedSourceVersion 获取该注解处理器最大支持的版本，默认从 @SupportedSourceVersion 中读取\npublic SourceVersion getSupportedSourceVersion() @SupportedSourceVersion 使用，指定版本 SourceVersion.RELEASE_17\n@SupportedSourceVersion(SourceVersion.RELEASE_17) public class DemoProcessor extends AbstractProcessor { } process 是注解处理器核心方法，注解的处理和生成代码或者配置资源都是在这个方法中完成\npublic boolean process(Set\u0026lt;? extends TypeElement\u0026gt; annotations, RoundEnvironment roundEnv) process 方法提供了两个参数，第一个是我们请求处理注解类型的集合（ getSupportedAnnotationTypes 方法所返回的注解类型），第二个是有关当前和上一次循环的信息的环境。返回值表示这些注解是否由此处理器声明\n如果返回 true，则这些注解不会被后续处理器处理\n如果返回 false，则这些注解可以被后续的处理器处理\n自定义注解处理器 目的：根据注解自动生成 getter/setter 以及引入日志\n环境配置 在我们原有类中新增信息需要修改修改 抽象语法树（AST），主要依靠 com.sun.tools 来操作\nJDK 1.8 可以通过引入 tools.jar 来实现访问 com.sun.tools 包\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.sun\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tools\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.8\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;system\u0026lt;/scope\u0026gt; \u0026lt;systemPath\u0026gt;${java.home}/../lib/tools.jar\u0026lt;/systemPath\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; JDK 1.9 开始引入模块系统，需要自定义编译选项通过 \u0026ndash;add-exports 来引入\n\u0026lt;compilerArgs\u0026gt; \u0026lt;arg\u0026gt;--add-exports=jdk.compiler/com.sun.tools.javac.api=ALL-UNNAMED\u0026lt;/arg\u0026gt; \u0026lt;arg\u0026gt;--add-exports=jdk.compiler/com.sun.tools.javac.code=ALL-UNNAMED\u0026lt;/arg\u0026gt; \u0026lt;arg\u0026gt;--add-exports=jdk.compiler/com.sun.tools.javac.processing=ALL-UNNAMED\u0026lt;/arg\u0026gt; \u0026lt;arg\u0026gt;--add-exports=jdk.compiler/com.sun.tools.javac.tree=ALL-UNNAMED\u0026lt;/arg\u0026gt; \u0026lt;arg\u0026gt;--add-exports=jdk.compiler/com.sun.tools.javac.util=ALL-UNNAMED\u0026lt;/arg\u0026gt; \u0026lt;/compilerArgs\u0026gt; 定义注解 定义 @Getter、@Setter、 @Log 三个注解，分别用来控制生成 getter/setter 以及引入日志\n@Target({ElementType.TYPE}) @Retention(RetentionPolicy.SOURCE) public @interface Getter { } @Target({ElementType.TYPE}) @Retention(RetentionPolicy.SOURCE) public @interface Setter { } @Target({ElementType.TYPE}) @Retention(RetentionPolicy.SOURCE) public @interface Log { } 编写注解处理器 定义一个抽象类 AbstractAnnotationProcessor 继承 AbstractProcessor，重写 init 和 getSupportedSourceVersion 方法\npublic abstract class AbstractAnnotationProcessor extends AbstractProcessor { // 解包装 ProcessingEnvironment 对象 protected ProcessingEnvironment unwrappedProcessingEnv; // 编译时期输入日志的 protected Messager messager; // 将Element转换为JCTree的工具,提供了待处理的抽象语法树 protected JavacTrees javacTrees; // 封装了创建AST节点的一些方法 protected TreeMaker treeMaker; // 提供了创建标识符的方法 protected Names names; /** * 支持 JDK 版本 */ @Override public SourceVersion getSupportedSourceVersion() { return SourceVersion.latestSupported(); } /** * 初始化一些操作语法树需要的对象 * * @param processingEnv environment to access facilities the tool framework * provides to the processor */ @Override public synchronized void init(ProcessingEnvironment processingEnv) { super.init(processingEnv); this.unwrappedProcessingEnv = jbUnwrap(processingEnv); this.messager = unwrappedProcessingEnv.getMessager(); this.javacTrees = JavacTrees.instance(unwrappedProcessingEnv); Context context = ((JavacProcessingEnvironment) unwrappedProcessingEnv).getContext(); this.treeMaker = TreeMaker.instance(context); this.names = Names.instance(context); } /** * IntelliJ IDEA 解包装 ProcessingEnvironment 对象，返回原始的 ProcessingEnvironment 对象 */ private ProcessingEnvironment jbUnwrap(ProcessingEnvironment wrapper) { ProcessingEnvironment unwrapped = null; try { final Class\u0026lt;?\u0026gt; apiWrappers = wrapper.getClass().getClassLoader().loadClass(\u0026#34;org.jetbrains.jps.javac.APIWrappers\u0026#34;); final Method unwrapMethod = apiWrappers.getDeclaredMethod(\u0026#34;unwrap\u0026#34;, Class.class, Object.class); unwrapped = (ProcessingEnvironment) unwrapMethod.invoke(null, ProcessingEnvironment.class, wrapper); } catch (Throwable ignored) { } return unwrapped != null ? unwrapped : wrapper; } /** * 变量处理程序 * * @param element 使用给定注解类型注解的元素 * @param func 特定执行函数 */ protected void variableHandler(Element element, BiFunction\u0026lt;JCTree.JCClassDecl, JCTree.JCVariableDecl, List\u0026lt;JCTree\u0026gt;\u0026gt; func) { javacTrees.getTree(element).accept(new TreeTranslator() { @Override public void visitClassDef(JCTree.JCClassDecl classDecl) { List\u0026lt;JCTree.JCVariableDecl\u0026gt; variableDecls = List.nil(); // 找到定义的相关变量 for (JCTree jcTree : classDecl.defs) { if (!jcTree.getKind().equals(Tree.Kind.VARIABLE)) { continue; } JCTree.JCVariableDecl jcVariableDecl = (JCTree.JCVariableDecl) jcTree; Set\u0026lt;Modifier\u0026gt; modifierSet = jcVariableDecl.getModifiers().getFlags(); if (modifierSet.contains(Modifier.FINAL) || modifierSet.contains(Modifier.STATIC)) { continue; } variableDecls = variableDecls.append(jcVariableDecl); } // 对定义的相关变量执行相应方法 variableDecls.forEach(item -\u0026gt; classDecl.defs = func.apply(classDecl, item)); super.visitClassDef(classDecl); } }); } /** * 字符串转字段访问链 * * @param components 字符串 */ protected JCTree.JCExpression strToJCFieldAccessChain(String components) { String[] componentArray = components.split(\u0026#34;\\\\.\u0026#34;); JCTree.JCExpression expr = treeMaker.Ident(names.fromString(componentArray[0])); for (int i = 1; i \u0026lt; componentArray.length; i++) { expr = treeMaker.Select(expr, names.fromString(componentArray[i])); } return expr; } /** * 编译期打印输出 * * @param msg 输出信息 */ protected void print(String msg) { messager.printMessage(Diagnostic.Kind.NOTE, msg); } } 编写 @Getter 对应的注解处理器 GetterProcessor，继承刚定义的抽象类 AbstractAnnotationProcessor，重写 getSupportedAnnotationTypes 和 process 方法。\npublic class GetterProcessor extends AbstractAnnotationProcessor { @Override public Set\u0026lt;String\u0026gt; getSupportedAnnotationTypes() { return Set.of(Getter.class.getName()); } @Override public boolean process(Set\u0026lt;? extends TypeElement\u0026gt; annotations, RoundEnvironment roundEnv) { roundEnv.getElementsAnnotatedWith(Getter.class).forEach(item -\u0026gt; variableHandler(item, this::makeGetMethodDecl)); return true; } /** * GET 方法生成 * * @param classDecl 定义的类 * @param variableDecl 定义的变量 */ private List\u0026lt;JCTree\u0026gt; makeGetMethodDecl(JCTree.JCClassDecl classDecl, JCTree.JCVariableDecl variableDecl) { ListBuffer\u0026lt;JCTree.JCStatement\u0026gt; statements = new ListBuffer\u0026lt;\u0026gt;(); // 构建 return this.variableName JCTree.JCReturn aReturn = treeMaker.Return(treeMaker.Select( treeMaker.Ident(names.fromString(\u0026#34;this\u0026#34;)), variableDecl.getName() )); statements.append(aReturn); JCTree.JCBlock block = treeMaker.Block(0, statements.toList()); String variableName = variableDecl.getName().toString(); // 构建方法 JCTree.JCMethodDecl method = treeMaker.MethodDef( treeMaker.Modifiers(Flags.PUBLIC), names.fromString(\u0026#34;get\u0026#34; + variableName.substring(0, 1).toUpperCase() + variableName.substring(1)), variableDecl.vartype, List.nil(), List.nil(), List.nil(), block, null ); // 添加方法到类 return classDecl.defs.append(method); } } 编写 @Setter 对应的注解处理器 SetterProcessor，继承刚定义的抽象类 AbstractAnnotationProcessor，重写 getSupportedAnnotationTypes 和 process 方法。\npublic class SetterProcessor extends AbstractAnnotationProcessor { @Override public Set\u0026lt;String\u0026gt; getSupportedAnnotationTypes() { return Set.of(Setter.class.getName()); } @Override public boolean process(Set\u0026lt;? extends TypeElement\u0026gt; annotations, RoundEnvironment roundEnv) { roundEnv.getElementsAnnotatedWith(Setter.class).forEach(item -\u0026gt; variableHandler(item, this::makeSetMethodDecl)); return true; } /** * SET 方法生成 * * @param classDecl 定义的类 * @param variableDecl 定义的变量 */ private List\u0026lt;JCTree\u0026gt; makeSetMethodDecl(JCTree.JCClassDecl classDecl, JCTree.JCVariableDecl variableDecl) { ListBuffer\u0026lt;JCTree.JCStatement\u0026gt; statements = new ListBuffer\u0026lt;\u0026gt;(); // 构建 this.variableName = variableName; JCTree.JCExpressionStatement expressionStatement = treeMaker.Exec(treeMaker.Assign( treeMaker.Select( treeMaker.Ident(names.fromString(\u0026#34;this\u0026#34;)), variableDecl.getName() ), treeMaker.Ident(variableDecl.getName()) )); statements.append(expressionStatement); JCTree.JCBlock block = treeMaker.Block(0, statements.toList()); // 生成方法参数之前，指明当前语法节点在语法树中的位置，避免出现异常 java.lang.AssertionError treeMaker.pos = variableDecl.pos; // 生成入参 JCTree.JCVariableDecl param = treeMaker.VarDef( treeMaker.Modifiers(Flags.PARAMETER), variableDecl.getName(), variableDecl.vartype, null ); List\u0026lt;JCTree.JCVariableDecl\u0026gt; parameters = List.of(param); String variableName = variableDecl.getName().toString(); // 构建方法 JCTree.JCMethodDecl method = treeMaker.MethodDef( treeMaker.Modifiers(Flags.PUBLIC), names.fromString(\u0026#34;set\u0026#34; + variableName.substring(0, 1).toUpperCase() + variableName.substring(1)), treeMaker.Type(new Type.JCVoidType()), List.nil(), parameters, List.nil(), block, null ); // 添加方法到类 return classDecl.defs.append(method); } } 编写 @Log 对应的注解处理器 LogProcessor，继承刚定义的抽象类 AbstractAnnotationProcessor，重写 getSupportedAnnotationTypes 和 process 方法。\npublic class LogProcessor extends AbstractAnnotationProcessor { private static final String LOGGER = Logger.class.getName(); private static final String LOGGER_FACTORY = LoggerFactory.class.getName(); @Override public Set\u0026lt;String\u0026gt; getSupportedAnnotationTypes() { return Set.of(Log.class.getName()); } @Override public boolean process(Set\u0026lt;? extends TypeElement\u0026gt; annotations, RoundEnvironment roundEnv) { roundEnv.getElementsAnnotatedWith(Log.class) .forEach(item -\u0026gt; javacTrees.getTree(item).accept(new TreeTranslator() { @Override public void visitClassDef(JCTree.JCClassDecl classDecl) { // 构建 private static final Logger log = LoggerFactory.getLogger(T.class); JCTree.JCVariableDecl variableDecl = treeMaker.VarDef( treeMaker.Modifiers(Flags.PRIVATE + Flags.STATIC + Flags.FINAL), names.fromString(\u0026#34;log\u0026#34;), strToJCFieldAccessChain(LOGGER), treeMaker.Apply( List.nil(), treeMaker.Select( strToJCFieldAccessChain(LOGGER_FACTORY), names.fromString(\u0026#34;getLogger\u0026#34;) ), List.of(strToJCFieldAccessChain(item.getSimpleName().toString() + \u0026#34;.class\u0026#34;)) ) ); classDecl.defs = classDecl.defs.prepend(variableDecl); super.visitClassDef(classDecl); } })); return true; } } 注册注解处理器 要让注解处理器生效，我们需要配置 SPI 配置文件:\n手动配置 在 resource/META-INF.services 文件夹下创建一个名为 javax.annotation.processing.Processor 的文件；内容是你的注解处理器的全限定类名\ncom.brainy.nonfia.apt.processor.LogProcessor com.brainy.nonfia.apt.processor.GetterProcessor com.brainy.nonfia.apt.processor.SetterProcessor 设置编译期间禁止处理 Processor，之所以这样做是因为，如果不禁止 Processor，ServiceLoader 就会去加载刚刚设置的注解处理器，但由于此时处理器本身尚未编译，所以会抛出 class not found 异常。所以我们需要配置 -proc:none 忽略 Processor\n\u0026lt;compilerArgs\u0026gt; \u0026lt;arg\u0026gt;-proc:none\u0026lt;/arg\u0026gt; \u0026lt;/compilerArgs\u0026gt; 自动配置 auto-service 是 Google 开源一个组件，它可以自动的帮我们生成 META-INF/services 的文件\n引入依赖\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.google.auto.service\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;auto-service\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 注解处理器上，加上注解，就会在编译期自动生成 SPI 配置文件\n@AutoService(Processor.class) public class GetterProcessor extends AbstractAnnotationProcessor { } 测试 mvn clean install 打包并安装到本地Maven仓库 新建一个项目，引入上面项目的依赖，写个测试类，编译后发现，Class 文件自动生成了 getter/setter 方法且引入了日志\n@Log @Getter @Setter public class Dog { private String name; private int age; } ","date":"2024-11-22T00:00:00Z","image":"https://picsum.photos/seed/738504757867b1674d476019f08842fb/800/600.webp","permalink":"/docs/java/standard/738504757867b1674d476019f08842fb/","title":"Java 插件化注解处理"},{"content":"Thymeleaf 介绍 Thymeleaf 是新一代 Java 模板引擎，它类似于 Velocity、FreeMarker 等传统 Java 模板引擎，但是与传统 Java 模板引擎不同的是，Thymeleaf 支持 HTML 原型。\n它既可以让前端工程师在浏览器中直接打开查看样式，也可以让后端工程师结合真实数据查看显示效果，同时，SpringBoot 提供了 Thymeleaf 自动化配置解决方案，因此在 SpringBoot 中使用 Thymeleaf 非常方便。\n事实上， Thymeleaf 除了展示基本的 HTML ，进行页面渲染之外，也可以作为一个 HTML 片段进行渲染，例如我们在做邮件发送时，可以使用 Thymeleaf 作为邮件发送模板。\nThymeleaf 官网\n引入依赖 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-thymeleaf\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 自动渲染 定义 Controller， 返回逻辑视图 index，Spring Boot 会到 resources/templates 目录下寻找一个名为 index.html 的 Thymeleaf 模板文件\n@GetMapping(\u0026#34;/\u0026#34;) public String index(Model model) { model.addAttribute(\u0026#34;name\u0026#34;, \u0026#34;nonfia\u0026#34;); model.addAttribute(\u0026#34;account\u0026#34;, \u0026#34;root\u0026#34;); return \u0026#34;index\u0026#34;; } 在 resources/templates 创建 Thymeleaf 模板文件 index.html\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34; xmlns:th=\u0026#34;http://www.thymeleaf.org\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;index\u0026lt;/title\u0026gt; \u0026lt;!-- js 获取数据 --\u0026gt; \u0026lt;script th:inline=\u0026#34;javascript\u0026#34;\u0026gt; let account = [[${account}]]; console.log(account) \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Hello!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Welcome to \u0026lt;span th:text=\u0026#34;${name}\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 手动渲染 新建一个邮件模板 mail.html\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34; xmlns:th=\u0026#34;http://www.thymeleaf.org\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;hello 你好 \u0026lt;span th:text=\u0026#34;${name}\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;您的工资信息如下：\u0026lt;/p\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;职位\u0026lt;/td\u0026gt; \u0026lt;td th:text=\u0026#34;${position}\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;薪水\u0026lt;/td\u0026gt; \u0026lt;td th:text=\u0026#34;${salary}\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 后端代码处理\n@Autowired TemplateEngine templateEngine; public void mail() throws MessagingException { Context context = new Context(); context.setVariable(\u0026#34;name\u0026#34;, \u0026#34;Tom\u0026#34;); context.setVariable(\u0026#34;position\u0026#34;, \u0026#34;工程师\u0026#34;); context.setVariable(\u0026#34;salary\u0026#34;, 88888); // 调用 process 方法进行渲染，该方法的返回值就是渲染后的 HTML 字符串 String mail = templateEngine.process(\u0026#34;mail\u0026#34;, context); } ","date":"2024-11-20T00:00:00Z","image":"https://picsum.photos/seed/05aa2367a9817122066433ef3b31eddc/800/600.webp","permalink":"/docs/java/springboot/05aa2367a9817122066433ef3b31eddc/","title":"Thymeleaf 模板引擎"},{"content":"Spring Boot Starter 介绍 Spring Boot Starter 是一组预定义的依赖项集合，旨在简化项目配置和依赖管理。每个 Starter 都包含了实现特定功能所需的库和组件，以及相应的配置文件。开发者只需在项目中引入相应的 Starter 依赖，即可快速搭建起具备该功能的项目骨架。\n此外，Spring Boot Starter 还遵循 约定优于配置 的原则，通过自动配置来减少手动配置的工作量。这意味着，只要项目中存在特定的类、资源或依赖项，Spring Boot就会自动应用相关的配置。\n总的来说，Spring Boot Starter 提供了一种快速、简便的方式来构建和配置 Spring Boot 应用程序。它使得开发者能够更专注于业务逻辑的实现，而无需花费大量时间在繁琐的配置和依赖管理上。\n主要特点 简化依赖管理：通过引入 Starter，开发者无需手动添加和管理大量的依赖项。 约定优于配置：通过默认的配置满足大多数场景的需求，减少了手动配置的工作量。 自动配置：Spring Boot 会根据 classpath 下的类、资源文件和 META-INF/spring.factories 配置文件自动配置项目所需的各种组件和服务。 易于扩展：开发者可以通过自定义 Starter 来扩展 Spring Boot 的功能，满足特定项目的需求。 自定义 Spring Boot Starter 引入依赖 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-autoconfigure\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring-boot.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 注解处理器 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-configuration-processor\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring-boot.version}\u0026lt;/version\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; 注解处理器 spring-boot-configuration-processor，可以在编译时生成元数据文件 META-INF/spring-configuration-metadata.json，元数据文件能够为在配置 application.yml 或者 application.properties 提供自动补全和文档支持\n定义服务接口 定义配置 EventProperties，用来接受 application.properties 中配置的值\n@ConfigurationProperties(prefix = \u0026#34;brainy.nonfia\u0026#34;) public class EventProperties { /** * 名称 */ private String name = \u0026#34;nonfia\u0026#34;; /** * 消息 */ private String msg = \u0026#34;hello, welcome use nonfia\u0026#34;; } 定义 EventService 接口和默认实现 DefaultEventService\npublic interface EventService { String say(); } public class DefaultEventService implements EventService { private final EventProperties eventProperties; DefaultEventService(EventProperties eventProperties) { this.eventProperties = eventProperties; } @Override public String say() { return eventProperties.getName() + \u0026#34;, \u0026#34; + eventProperties.getMsg(); } } 自动配置和打包 定义自动配置 EventManagementAutoConfiguration\n@AutoConfiguration @EnableConfigurationProperties(EventProperties.class) public class EventManagementAutoConfiguration { @Bean @ConditionalOnMissingBean public EventService eventService(EventProperties eventProperties) { return new DefaultEventService(eventProperties); } } 在 src/main/resources/META-INF 目录下创建 spring.factories 文件（Spring Boot 2.7 起不推荐使用 spring.factories 文件配置，3.x 版本弃用）并添加以下配置：\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\ com.brainy.nonfia.autoconfigure.EventManagementAutoConfiguration Spring Boot 3.x 版本后在 src/main/resources/META-INF/spring 目录下创建 org.springframework.boot.autoconfigure.AutoConfiguration.imports 文件，并添加以下配置：\ncom.brainy.nonfia.autoconfigure.EventManagementAutoConfiguration mvn clean install 打包并安装到本地Maven仓库， 在新项目引入依赖\n","date":"2024-11-19T00:00:00Z","image":"https://picsum.photos/seed/84b1fbe0502427f210938f23bc01b4ag/800/600.webp","permalink":"/docs/java/springboot/84b1fbe0502427f210938f23bc01b4ag/","title":"Spring Boot Starter"},{"content":"配置文件解析 Spring Boot 启动项目会默认加载名为 application 的配置文件，配置文件 配置文件有两种不同的格式，即 application.properties 和 application.yml， yaml 格式的数据是有序的，properties 格式的数据是无序的\n配置文件的位置 application.properties 和 application.yml 文件可以放在以下四个位置：\n外置，当前项目根目录下的 config 目录下 外置，当前项目的根目录下 内置，resources 目录下的 config 目录下 内置，resources 目录下 如上顺序，四个配置文件的优先级依次降低\n此外，如果你在相同优先级位置同时有 application.properties 和 application.yml，那么 application.properties 会覆盖 application.yml。\n自定义配置文件 自定义配置文件名 项目启动时指定配置文件的名字，在项目启动时加载名为 app 的配置文件而不是 application。\nspring.config.name=app 自定义配置文件位置 重新定义配置文件的位置，此参数会覆盖掉默认的四个位置\nspring.config.location=classpath:/custom-location/ 在默认的四个位置的基础上，再添加几个位置，新添加位置的优先级大于原本的位置\nspring.config.additional-location=classpath:/custom-location/ 自定义属性 application.properties 中添加\nbook.name=西游记 book.author=吴承恩 book.price=18 各个参数之间也可以直接引用\nbook.name=西游记 book.author=吴承恩 book.price=18 book.desc=${book.name}是${book.author}写的 普通的属性注入 直接通过 @Value 注解注入配置文件的属性\n@Value(\u0026#34;${book.name}\u0026#34;) private String name; @Value(\u0026#34;${book.author}\u0026#34;) private String author; @Value(\u0026#34;${book.price}\u0026#34;) private int price; @Value(\u0026#34;${book.price}\u0026#34;) private String desc; 如果不希望把所有配置都放在 application.properties 里面，也可以新定义一个配置文件，例如在 resources 目录下，自定义 book.properties 文件\nbook.name=西游记 book.author=吴承恩 book.price=18 book.desc=${book.name}是${book.author}写的 此时需要通过 @PropertySource 注解来引入配置\n@Component @PropertySource(\u0026#34;classpath:book.properties\u0026#34;) @ConfigurationProperties(prefix = \u0026#34;book\u0026#34;) public class Book { private String name; private String author; private int price; private String desc; } 类型安全的属性注入 引入 @ConfigurationProperties 注解，同时配置了属性的前缀 prefix = \u0026ldquo;book\u0026rdquo;，此时会自动将配置文件的属性注入到对象对应的属性中\n@Component @ConfigurationProperties(prefix = \u0026#34;book\u0026#34;) public class Book { private String name; private String author; private int price; private String desc; } 多环境配置 在 Spring Boot 中多环境配置文件名需要满足 application-{profile}.properties 的格式，其中 {profile} 对应你的环境标识，比如：\napplication-dev.properties：开发环境 application-prod.properties：生产环境 使用对应的环境，只需要在 application.properties 中使用 spring.profiles.active 属性来设置\nspring.profiles.active=dev 除却 spring.profiles.active 来激活一个或者多个 Profile 之外，还可以用 spring.profiles.include 来叠加 Profile。\nspring.profiles.include=db, redis 为了进一步简化为不同环境定义属性的过程，甚至可以将所有属性放在同一个文件中，并使用分隔符来表示 Profile。\nspring.profiles.active=dev #--- spring.config.activate.on-profile=dev book.name=西游记 book.author=吴承恩 book.price=18 book.desc=${book.name}是${book.author}写的 #--- spring.config.activate.on-profile=prod book.name=三国演义 book.author=罗贯中 book.price=18 book.desc=${book.name}是${book.author}写的 ","date":"2024-11-18T00:00:00Z","image":"https://picsum.photos/seed/00f493c93a3f4cc188ddebd4d3ea26f2/800/600.webp","permalink":"/docs/java/springboot/00f493c93a3f4cc188ddebd4d3ea26f2/","title":"配置文件解析"},{"content":"Spring Boot 介绍 Spring Boot是由 Pivotal 团队提供的一套开源框架，可以简化 spring 应用的创建及部署。它提供了丰富的 Spring 模块化支持，可以帮助开发者更轻松快捷地构建出企业级应用。Spring Boot 通过自动配置功能，降低了复杂性，同时支持基于 JVM 的多种开源框架，可以缩短开发时间，使开发更加简单和高效。\nSpring Boot 官网\nSpring Boot 中文文档\n创建方式 在线创建 打开Spring Initializr 官网\n这里要配置的按顺序分别如下：\nProject : 它定义项目的种类。我们可以创建 Maven 项目或 Gradle 项目。 Language : Spring Initializr 提供了三种语言 Java，Kotlin，和 Groovy 的选择。 Spring Boot : 可以选择 Spring Boot 版本。 Project Metadata : 它包含与项目相关的信息，例如 Group，Artifact 等。 Dependencies : 添加到项目中的依赖。 所有的事情全部完成后，点击最下面的 Generate，此时会自动下载项目，将下载下来的项目解压，然后用 IntelliJ IDEA 或者 Eclipse 打开即可进行开发。\n开发工具创建（IntelliJ IDEA） 首先在创建项目时选择 Spring boot\n接下来选择需要添加的依赖\n勾选完成后，点击 创建 完成项目的创建。\n项目结构 根据上面的操作已经初始化了一个 Spring Boot 的框架了，项目结构如下：\n此时项目里面基本没有代码，除了空目录外，还包含如下几样东西。\npom.xml：Maven 构建说明文件。 DemoApplication.java：一个带有 main() 方法的类，用于启动应用程序。 DemoApplicationTests.java：一个空的 Junit 测试类，它加载了一个使用 Spring Boot 字典配置功能的 Spring 应用程序上下文。 application.properties：一个空的 properties 文件，你可以根据需要添加配置属性。 运行项目 修改 DemoApplication.java\n@RestController @SpringBootApplication public class DemoApplication { public static void main(String[] args) { SpringApplication.run(DemoApplication.class, args); } @GetMapping(\u0026#34;/\u0026#34;) public String hello() { return \u0026#34;Hello World\u0026#34;; } } 运行项目，控制台打印如下\n此时浏览器输入 http://localhost:8080 浏览器会打印 Hello World\n","date":"2024-11-17T00:00:00Z","image":"https://picsum.photos/seed/ab2098abbc2e93731d313aaddebe260j/800/600.webp","permalink":"/docs/java/springboot/ab2098abbc2e93731d313aaddebe260j/","title":"Spring Boot 创建"},{"content":"Hugo 介绍 Hugo 是一个用 Go 编写的静态站点生成器，可以快速方便的创建自己的博客。\nHugo 支持 Markdown 语法，我们可以将自己的文章写成 Markdown 的格式，放在我们用Hugo 创建的博客系统中，从而展示给他人。\nHugo 官网\nHugo安装 Windows 推荐直接使用 winget 的方式安装 Hugo，其他操作系统的安装方法可以查阅官方文档\nwinget install Hugo.Hugo.Extended 验证安装是否成功\nhugo version 网站配置 创建站点 hugo new site blog.source 在 GitHub 上创建两个仓库，blog.source 和 xxx.github.io，其中 blog.source 是你的博客源仓库，xxx.github.io 是你的 GitHub Pages 仓库， xxx 是你的 GitHub 用户名\n将本地文件夹 blog.source 初始化为 git 仓库，并将远程仓库地址设置为 GitHub 上 blog.source 的仓库地址\ngit init -b main git remote add origin remoteAddr git add . git commit -m \u0026#34;init\u0026#34; git push -u origin main 安装主题 Hugo社区 上找到一款你喜欢的主题，此处以 theme-stack-starter 为例\n添加为子模块 我们的网站已经使用le Git，可以通过以下命令来将主题作为子模块使用\ngit submodule add https://github.com/CaiJimmy/hugo-theme-stack/ themes/hugo-theme-stack Hugo module 为了让我们项目不参杂其他文件，此处以 Hugo module 方法安装主题，使用此方法，项目目录下不会有其他文件。当修改主题，你必须将要修改的文件复制到 项目根目录下的同一目录中。\n首先将你的网站变成一个 Hugo 模块\nhugo mod init github.com/name/blog.source 然后将主题作为依赖项导入，在站点配置文件添加以下内容\nmodule: imports: - path: github.com/CaiJimmy/hugo-theme-stack/v3 运行以下命令将主题更新到最新版本\nhugo mod get -u github.com/CaiJimmy/hugo-theme-stack/v3 hugo mod tidy 配置修改 将 exampelSite 文件夹中的 Content 和 hugo.yaml 复制到项目根目录中，并删掉hugo.toml\n子模块添加的主题， exampelSite 文件夹在 /themes/hugo-theme-stack 下 Hugo module，进入 GitHub 获取 exampelSite 文件夹 根据配置文件的注释和主题的官方文档修改配置，需要注意以下配置\n# 网站地址\u0026lt;user\u0026gt;.github.io baseurl: https://example.com # 网站名 title: Example Site # Hugo module 安装 不需要此配置 theme: hugo-theme-stack # 中文博客注意修改成 zh-cn DefaultContentLanguage: en # DefaultContentLanguage 是 zh-cn 时，修改为true hasCJKLanguage: false # 头像位置 assets/img/avatar.png sidebar: avatar: src: img/avatar.png # 使用数学公式需要打开 article: math: true # 图标位置 static/icon/favicon.ico params: favicon: /icon/favicon.ico GitHub 自动发布 登录 GitHub，前往 settings -\u0026gt; Developer Settings -\u0026gt; Personal access tokens，创建 token(classic)\ntoken 选择永不过期，并且勾选 repo 和 workflow 选项\n为保证安全，将生成的 token，保存在 blog.source 仓库的变量中，前往 Settings -\u0026gt; Secrets and variables -\u0026gt; Actions （注意：token只能显示一次，需事先保存）\n创建 hugo 工作流文件， 进入 blog.source 仓库，前往 actions -\u0026gt; new workflow，找到 Pages 下的 Hugo，点击 configure 生成工作流文件\n修改配置文件 .github\\workflows\\hugo.yml\n# Sample workflow for building and deploying a Hugo site to GitHub Pages name: Deploy Hugo site to Pages on: # Runs on pushes targeting the default branch push: branches: [\u0026#34;main\u0026#34;] # Allows you to run this workflow manually from the Actions tab workflow_dispatch: # Default to bash defaults: run: shell: bash jobs: # Build job build: runs-on: ubuntu-latest env: # 你的 Hugo 版本 HUGO_VERSION: 0.128.0 steps: - name: Install Hugo CLI run: | wget -O ${{ runner.temp }}/hugo.deb https://github.com/gohugoio/hugo/releases/download/v${HUGO_VERSION}/hugo_extended_${HUGO_VERSION}_linux-amd64.deb \\ \u0026amp;\u0026amp; sudo dpkg -i ${{ runner.temp }}/hugo.deb - name: Install Dart Sass run: sudo snap install dart-sass - name: Checkout uses: actions/checkout@v4 with: submodules: recursive - name: Install Node.js dependencies run: \u0026#34;[[ -f package-lock.json || -f npm-shrinkwrap.json ]] \u0026amp;\u0026amp; npm ci || true\u0026#34; - name: Build with Hugo env: HUGO_CACHEDIR: ${{ runner.temp }}/hugo_cache HUGO_ENVIRONMENT: production run: | hugo \\ --minify \\ --baseURL \u0026#34;${{ steps.pages.outputs.base_url }}/\u0026#34; - name: Deploy to GitHub Pages uses: peaceiris/actions-gh-pages@v4 with: # Token personal_token: ${{ secrets.TOKEN }} # Github Pages 仓库 external_repository: xxx/xxx.github.io # 推送 main 分支 publish_branch: main publish_dir: ./public 接下来直接 push 本地的修改到远程 blog.source 仓库，Github Action 就会自动编译部署 GitHub Pages\n验证 创建文章 使用 Hugo 创建文章，生成的 Markdowen 文件的元数据中 image 可以指定文章封面，draft 表示文章是否属于草稿，草稿文件不会被发布，hidden 表示文章是否会被隐藏\nhugo new post/test/index.md 编写完成后可以使用以下命令预览\nhugo server -D blog.source 源仓库添加 .gitignore， 去除编译后文件\npublic/ resources/ assets/jsconfig.json .hugo_build.lock 推送到远程仓库\ngit commit -m \u0026#34;First commit\u0026#34; git push -u origin main 进入网站 xxx.github.io 验证\n","date":"2024-05-04T00:00:00Z","image":"https://picsum.photos/seed/41902ba42801a0271bec7f7324d1a05d/800/600.webp","permalink":"/docs/toss/41902ba42801a0271bec7f7324d1a05d/","title":"使用 Hugo + Github Pages 搭建个人博客"}]